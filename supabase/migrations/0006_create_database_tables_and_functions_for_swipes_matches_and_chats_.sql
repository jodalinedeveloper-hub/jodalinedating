-- Create a table to record user swipes
CREATE TABLE public.swipes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  swiper_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  swiped_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  action TEXT NOT NULL CHECK (action IN ('like', 'pass')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (swiper_id, swiped_id)
);
-- Add security policies for swipes
ALTER TABLE public.swipes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can insert their own swipes" ON public.swipes
FOR INSERT TO authenticated WITH CHECK (auth.uid() = swiper_id);
CREATE POLICY "Users can only see their own outgoing likes" ON public.swipes
FOR SELECT TO authenticated USING (auth.uid() = swiper_id);

-- Create a table to store matches
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user1_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  user2_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT check_user_order CHECK (user1_id < user2_id),
  UNIQUE (user1_id, user2_id)
);
-- Add security policies for matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own matches" ON public.matches
FOR SELECT TO authenticated USING (auth.uid() = user1_id OR auth.uid() = user2_id);

-- Create a table to store chat messages
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  match_id BIGINT NOT NULL REFERENCES public.matches(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
-- Add security policies for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
-- Helper function to check if a user is part of a match
CREATE OR REPLACE FUNCTION is_part_of_match(match_id_to_check BIGINT)
RETURNS BOOLEAN LANGUAGE SQL SECURITY DEFINER AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.matches
    WHERE id = match_id_to_check AND (user1_id = auth.uid() OR user2_id = auth.uid())
  );
$$;
CREATE POLICY "Users can see messages in their matches" ON public.messages
FOR SELECT TO authenticated USING (is_part_of_match(match_id));
CREATE POLICY "Users can send messages in their matches" ON public.messages
FOR INSERT TO authenticated WITH CHECK (is_part_of_match(match_id) AND auth.uid() = sender_id);

-- Create a database function to handle likes and create matches atomically
CREATE OR REPLACE FUNCTION public.handle_like(swiped_user_id UUID)
RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  current_user_id UUID := auth.uid();
  is_match BOOLEAN := false;
  new_match_id BIGINT;
  user1 UUID;
  user2 UUID;
BEGIN
  INSERT INTO public.swipes (swiper_id, swiped_id, action)
  VALUES (current_user_id, swiped_user_id, 'like')
  ON CONFLICT (swiper_id, swiped_id) DO NOTHING;

  SELECT EXISTS (
    SELECT 1 FROM public.swipes
    WHERE swiper_id = swiped_user_id AND swiped_id = current_user_id AND action = 'like'
  ) INTO is_match;

  IF is_match THEN
    IF current_user_id < swiped_user_id THEN
      user1 := current_user_id;
      user2 := swiped_user_id;
    ELSE
      user1 := swiped_user_id;
      user2 := current_user_id;
    END IF;
    INSERT INTO public.matches (user1_id, user2_id)
    VALUES (user1, user2)
    ON CONFLICT (user1_id, user2_id) DO NOTHING
    RETURNING id INTO new_match_id;
  END IF;
  RETURN json_build_object('is_match', is_match, 'match_id', new_match_id);
END;
$$;

-- Enable realtime on new tables so chats and matches update live
ALTER PUBLICATION supabase_realtime ADD TABLE public.matches;
ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;